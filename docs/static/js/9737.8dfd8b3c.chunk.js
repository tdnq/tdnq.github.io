"use strict";(globalThis.webpackChunktdnq_github_io=globalThis.webpackChunktdnq_github_io||[]).push([[9737],{9737:(e,t,r)=>{r.d(t,{qf:()=>i,$1:()=>n});var o=r(3562);function i(e,t=!1){const r=null!==e[0].index,i=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),u={},l={},a=e[0].morphTargetsRelative,f=new o.u9r;let m=0;for(let o=0;o<e.length;++o){const s=e[o];let h=0;if(r!==(null!==s.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in s.attributes){if(!i.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[e]&&(u[e]=[]),u[e].push(s.attributes[e]),h++}if(h!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". Make sure all geometries have the same number of attributes."),null;if(a!==s.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in s.morphAttributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===l[e]&&(l[e]=[]),l[e].push(s.morphAttributes[e])}if(f.userData.mergedUserData=f.userData.mergedUserData||[],f.userData.mergedUserData.push(s.userData),t){let e;if(r)e=s.index.count;else{if(void 0===s.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". The geometry must have either an index or a position attribute"),null;e=s.attributes.position.count}f.addGroup(m,e,o),m+=e}}if(r){let t=0;const r=[];for(let o=0;o<e.length;++o){const i=e[o].index;for(let e=0;e<i.count;++e)r.push(i.getX(e)+t);t+=e[o].attributes.position.count}f.setIndex(r)}for(const o in u){const e=s(u[o]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+o+" attribute."),null;f.setAttribute(o,e)}for(const o in l){const e=l[o][0].length;if(0===e)break;f.morphAttributes=f.morphAttributes||{},f.morphAttributes[o]=[];for(let t=0;t<e;++t){const e=[];for(let i=0;i<l[o].length;++i)e.push(l[o][i][t]);const r=s(e);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+o+" morphAttribute."),null;f.morphAttributes[o].push(r)}}return f}function s(e){let t,r,i,s=0;for(let o=0;o<e.length;++o){const n=e[o];if(n.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=n.array.constructor),t!==n.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=n.itemSize),r!==n.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===i&&(i=n.normalized),i!==n.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;s+=n.array.length}const n=new t(s);let u=0;for(let o=0;o<e.length;++o)n.set(e[o].array,u),u+=e[o].array.length;return new o.TlE(n,r,i)}function n(e,t=1e-4){t=Math.max(t,Number.EPSILON);const r={},i=e.getIndex(),s=e.getAttribute("position"),n=i?i.count:s.count;let u=0;const l=Object.keys(e.attributes),a={},f={},m=[],h=["getX","getY","getZ","getW"];for(let o=0,d=l.length;o<d;o++){const t=l[o];a[t]=[];const r=e.morphAttributes[t];r&&(f[t]=new Array(r.length).fill().map((()=>[])))}const c=Math.log10(1/t),g=Math.pow(10,c);for(let o=0;o<n;o++){const t=i?i.getX(o):o;let s="";for(let r=0,o=l.length;r<o;r++){const o=l[r],i=e.getAttribute(o),n=i.itemSize;for(let e=0;e<n;e++)s+=~~(i[h[e]](t)*g)+","}if(s in r)m.push(r[s]);else{for(let r=0,o=l.length;r<o;r++){const o=l[r],i=e.getAttribute(o),s=e.morphAttributes[o],n=i.itemSize,u=a[o],m=f[o];for(let e=0;e<n;e++){const r=h[e];if(u.push(i[r](t)),s)for(let e=0,o=s.length;e<o;e++)m[e].push(s[e][r](t))}}r[s]=u,m.push(u),u++}}const b=e.clone();for(let d=0,p=l.length;d<p;d++){const t=l[d],r=e.getAttribute(t),i=new r.array.constructor(a[t]),s=new o.TlE(i,r.itemSize,r.normalized);if(b.setAttribute(t,s),t in f)for(let n=0;n<f[t].length;n++){const r=e.morphAttributes[t][n],i=new r.array.constructor(f[t][n]),s=new o.TlE(i,r.itemSize,r.normalized);b.morphAttributes[t][n]=s}}return b.setIndex(m),b}}}]);