"use strict";(globalThis.webpackChunktdnq_github_io=globalThis.webpackChunktdnq_github_io||[]).push([[7744],{7744:(t,e,n)=>{n.d(e,{u:()=>m});var s=n(3562);const i=new s.Pa4,r=new s.Zzh,o=new s.JOQ,a=new s.Pa4,l=new s.CJI;class h{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new p,this.unassigned=new p,this.vertices=[]}setFromPoints(t){!0!==Array.isArray(t)&&console.error("THREE.ConvexHull: Points parameter is not an array."),t.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.vertices.push(new d(t[e]));return this.compute(),this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse((function(t){const n=t.geometry;if(void 0!==n){if(n.isGeometry)return void console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");if(n.isBufferGeometry){const i=n.attributes.position;if(void 0!==i)for(let n=0,r=i.count;n<r;n++){const r=new s.Pa4;r.fromBufferAttribute(i,n).applyMatrix4(t.matrixWorld),e.push(r)}}}})),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let n=0,s=e.length;n<s;n++){if(e[n].distanceToPoint(t)>this.tolerance)return!1}return!0}intersectRay(t,e){const n=this.faces;let s=-1/0,i=1/0;for(let r=0,o=n.length;r<o;r++){const e=n[r],o=e.distanceToPoint(t.origin),a=e.normal.dot(t.direction);if(o>0&&a>=0)return null;const l=0!==a?-o/a:0;if(!(l<=0)&&(a>0?i=Math.min(l,i):s=Math.max(l,s),s>i))return null}return s!==-1/0?t.at(s,e):t.at(i,e),e}intersectsRay(t){return null!==this.intersectRay(t,i)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let n=t.outside;for(;null!==n.next&&n.next.face===t;)n=n.next;return this.assigned.removeSubList(e,n),e.prev=n.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const n=this.removeAllVerticesFromFace(t);if(void 0!==n)if(void 0===e)this.unassigned.appendChain(n);else{let t=n;do{const n=t.next;e.distanceToPoint(t.point)>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=n}while(null!==t)}return this}resolveUnassignedPoints(t){if(!1===this.unassigned.isEmpty()){let e=this.unassigned.first();do{const n=e.next;let s=this.tolerance,i=null;for(let r=0;r<t.length;r++){const n=t[r];if(0===n.mark){const t=n.distanceToPoint(e.point);if(t>s&&(s=t,i=n),s>1e3*this.tolerance)break}}null!==i&&this.addVertexToFace(e,i),e=n}while(null!==e)}return this}computeExtremes(){const t=new s.Pa4,e=new s.Pa4,n=[],i=[];for(let s=0;s<3;s++)n[s]=i[s]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let s=0,r=this.vertices.length;s<r;s++){const r=this.vertices[s],o=r.point;for(let e=0;e<3;e++)o.getComponent(e)<t.getComponent(e)&&(t.setComponent(e,o.getComponent(e)),n[e]=r);for(let t=0;t<3;t++)o.getComponent(t)>e.getComponent(t)&&(e.setComponent(t,o.getComponent(t)),i[t]=r)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:n,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),n=e.min,s=e.max;let i=0,l=0;for(let r=0;r<3;r++){const t=s[r].point.getComponent(r)-n[r].point.getComponent(r);t>i&&(i=t,l=r)}const h=n[l],u=s[l];let d,p;i=0,r.set(h.point,u.point);for(let o=0,c=this.vertices.length;o<c;o++){const e=t[o];if(e!==h&&e!==u){r.closestPointToPoint(e.point,!0,a);const t=a.distanceToSquared(e.point);t>i&&(i=t,d=e)}}i=-1,o.setFromCoplanarPoints(h.point,u.point,d.point);for(let r=0,a=this.vertices.length;r<a;r++){const e=t[r];if(e!==h&&e!==u&&e!==d){const t=Math.abs(o.distanceToPoint(e.point));t>i&&(i=t,p=e)}}const m=[];if(o.distanceToPoint(p.point)<0){m.push(c.create(h,u,d),c.create(p,u,h),c.create(p,d,u),c.create(p,h,d));for(let t=0;t<3;t++){const e=(t+1)%3;m[t+1].getEdge(2).setTwin(m[0].getEdge(e)),m[t+1].getEdge(1).setTwin(m[e+1].getEdge(0))}}else{m.push(c.create(h,d,u),c.create(p,h,u),c.create(p,u,d),c.create(p,d,h));for(let t=0;t<3;t++){const e=(t+1)%3;m[t+1].getEdge(2).setTwin(m[0].getEdge((3-t)%3)),m[t+1].getEdge(0).setTwin(m[e+1].getEdge(1))}}for(let r=0;r<4;r++)this.faces.push(m[r]);for(let r=0,o=t.length;r<o;r++){const e=t[r];if(e!==h&&e!==u&&e!==d&&e!==p){i=this.tolerance;let t=null;for(let n=0;n<4;n++){const s=this.faces[n].distanceToPoint(e.point);s>i&&(i=s,t=this.faces[n])}null!==t&&this.addVertexToFace(e,t)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const n=this.faces[e];0===n.mark&&t.push(n)}return this.faces=t,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const n=this.assigned.first().face;let s=n.outside;do{const i=n.distanceToPoint(s.point);i>e&&(e=i,t=s),s=s.next}while(null!==s&&s.face===n);return t}}computeHorizon(t,e,n,s){let i;this.deleteFaceVertices(n),n.mark=1,i=null===e?e=n.getEdge(0):e.next;do{const e=i.twin,n=e.face;0===n.mark&&(n.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,e,n,s):s.push(i)),i=i.next}while(i!==e);return this}addAdjoiningFace(t,e){const n=c.create(t,e.tail(),e.head());return this.faces.push(n),n.getEdge(-1).setTwin(e.twin),n.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let n=null,s=null;for(let i=0;i<e.length;i++){const r=e[i],o=this.addAdjoiningFace(t,r);null===n?n=o:o.next.setTwin(s),this.newFaces.push(o.face),s=o}return n.next.setTwin(s),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class c{constructor(){this.normal=new s.Pa4,this.midpoint=new s.Pa4,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}static create(t,e,n){const s=new c,i=new u(t,s),r=new u(e,s),o=new u(n,s);return i.next=o.prev=r,r.next=i.prev=o,o.next=r.prev=i,s.edge=i,s.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),n=this.edge.next.head();return l.set(t.point,e.point,n.point),l.getNormal(this.normal),l.getMidpoint(this.midpoint),this.area=l.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class u{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class d{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class p{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}class m extends s.u9r{constructor(t){super();const e=[],n=[];void 0===h&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");const i=(new h).setFromPoints(t).faces;for(let s=0;s<i.length;s++){const t=i[s];let r=t.edge;do{const s=r.head().point;e.push(s.x,s.y,s.z),n.push(t.normal.x,t.normal.y,t.normal.z),r=r.next}while(r!==t.edge)}this.setAttribute("position",new s.a$l(e,3)),this.setAttribute("normal",new s.a$l(n,3))}}}}]);