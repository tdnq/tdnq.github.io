"use strict";(globalThis.webpackChunktdnq_github_io=globalThis.webpackChunktdnq_github_io||[]).push([[1976,9637],{9637:(e,t,s)=>{function i(e){var t;null===(t=e.querySelectorAll("canvas"))||void 0===t||t.forEach((e=>e.remove()))}s.d(t,{e:()=>i})},1976:(e,t,s)=>{s.r(t),s.d(t,{default:()=>b});var i=s(3562),r=s(2518),n=s(9637),a=s(5165),o={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"};class h{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const l=new i.iKG(-1,1,1,-1,0,1),c=new i.u9r;c.setAttribute("position",new i.a$l([-1,3,0,-1,-1,0,3,-1,0],3)),c.setAttribute("uv",new i.a$l([0,2,0,0,2,0],2));class d{constructor(e){this._mesh=new i.Kj0(c,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,l)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class u extends h{constructor(e,t){super(),this.textureID=void 0!==t?t:"tDiffuse",e instanceof i.jyz?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=i.rDY.clone(e.uniforms),this.material=new i.jyz({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new d(this.material)}render(e,t,s){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=s.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}class f extends h{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,s){const i=e.getContext(),r=e.state;let n,a;r.buffers.color.setMask(!1),r.buffers.depth.setMask(!1),r.buffers.color.setLocked(!0),r.buffers.depth.setLocked(!0),this.inverse?(n=0,a=1):(n=1,a=0),r.buffers.stencil.setTest(!0),r.buffers.stencil.setOp(i.REPLACE,i.REPLACE,i.REPLACE),r.buffers.stencil.setFunc(i.ALWAYS,n,4294967295),r.buffers.stencil.setClear(a),r.buffers.stencil.setLocked(!0),e.setRenderTarget(s),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),r.buffers.color.setLocked(!1),r.buffers.depth.setLocked(!1),r.buffers.stencil.setLocked(!1),r.buffers.stencil.setFunc(i.EQUAL,1,4294967295),r.buffers.stencil.setOp(i.KEEP,i.KEEP,i.KEEP),r.buffers.stencil.setLocked(!0)}}class m extends h{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class v{constructor(e,t){if(this.renderer=e,void 0===t){const s={minFilter:i.wem,magFilter:i.wem,format:i.wk1},r=e.getSize(new i.FM8);this._pixelRatio=e.getPixelRatio(),this._width=r.width,this._height=r.height,(t=new i.dd2(this._width*this._pixelRatio,this._height*this._pixelRatio,s)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===o&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===u&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new u(o),this.clock=new i.SUY}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let s=!1;for(let i=0,r=this.passes.length;i<r;i++){const t=this.passes[i];if(!1!==t.enabled){if(t.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(i),t.render(this.renderer,this.writeBuffer,this.readBuffer,e,s),t.needsSwap){if(s){const t=this.renderer.getContext(),s=this.renderer.state.buffers.stencil;s.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),s.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==f&&(t instanceof f?s=!0:t instanceof m&&(s=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new i.FM8);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio,i=this._height*this._pixelRatio;this.renderTarget1.setSize(s,i),this.renderTarget2.setSize(s,i);for(let r=0;r<this.passes.length;r++)this.passes[r].setSize(s,i)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}}new i.iKG(-1,1,1,-1,0,1);const g=new i.u9r;g.setAttribute("position",new i.a$l([-1,3,0,-1,-1,0,3,-1,0],3)),g.setAttribute("uv",new i.a$l([0,2,0,0,2,0],2));class p extends h{constructor(e,t,s,r,n){super(),this.scene=e,this.camera=t,this.overrideMaterial=s,this.clearColor=r,this.clearAlpha=void 0!==n?n:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new i.Ilk}render(e,t,s){const i=e.autoClear;let r,n;e.autoClear=!1,void 0!==this.overrideMaterial&&(n=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),r=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:s),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,r),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=n),e.autoClear=i}}const w={defines:{KERNEL_SIZE_FLOAT:"25.0",KERNEL_SIZE_INT:"25"},uniforms:{tDiffuse:{value:null},uImageIncrement:{value:new i.FM8(.001953125,0)},cKernel:{value:[]}},vertexShader:"\n\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float cKernel[ KERNEL_SIZE_INT ];\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 imageCoord = vUv;\n\t\t\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\n\n\t\t\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\n\t\t\t\timageCoord += uImageIncrement;\n\n\t\t\t}\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}",buildKernel:function(e){let t=2*Math.ceil(3*e)+1;t>25&&(t=25);const s=.5*(t-1),i=new Array(t);let r=0;for(let n=0;n<t;++n)i[n]=x(n-s,e),r+=i[n];for(let n=0;n<t;++n)i[n]/=r;return i}};function x(e,t){return Math.exp(-e*e/(2*t*t))}class T extends h{constructor(e=1,t=25,s=4,r=256){super();const n={minFilter:i.wem,magFilter:i.wem,format:i.wk1};this.renderTargetX=new i.dd2(r,r,n),this.renderTargetX.texture.name="BloomPass.x",this.renderTargetY=new i.dd2(r,r,n),this.renderTargetY.texture.name="BloomPass.y",void 0===o&&console.error("THREE.BloomPass relies on CopyShader");const a=o;this.copyUniforms=i.rDY.clone(a.uniforms),this.copyUniforms.opacity.value=e,this.materialCopy=new i.jyz({uniforms:this.copyUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,blending:i.WMw,transparent:!0}),void 0===w&&console.error("THREE.BloomPass relies on ConvolutionShader");const h=w;this.convolutionUniforms=i.rDY.clone(h.uniforms),this.convolutionUniforms.uImageIncrement.value=T.blurX,this.convolutionUniforms.cKernel.value=w.buildKernel(s),this.materialConvolution=new i.jyz({uniforms:this.convolutionUniforms,vertexShader:h.vertexShader,fragmentShader:h.fragmentShader,defines:{KERNEL_SIZE_FLOAT:t.toFixed(1),KERNEL_SIZE_INT:t.toFixed(0)}}),this.needsSwap=!1,this.fsQuad=new d(null)}render(e,t,s,i,r){r&&e.state.buffers.stencil.setTest(!1),this.fsQuad.material=this.materialConvolution,this.convolutionUniforms.tDiffuse.value=s.texture,this.convolutionUniforms.uImageIncrement.value=T.blurX,e.setRenderTarget(this.renderTargetX),e.clear(),this.fsQuad.render(e),this.convolutionUniforms.tDiffuse.value=this.renderTargetX.texture,this.convolutionUniforms.uImageIncrement.value=T.blurY,e.setRenderTarget(this.renderTargetY),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetY.texture,r&&e.state.buffers.stencil.setTest(!0),e.setRenderTarget(s),this.clear&&e.clear(),this.fsQuad.render(e)}}T.blurX=new i.FM8(.001953125,0),T.blurY=new i.FM8(0,.001953125);const S={uniforms:{tDiffuse:{value:null},time:{value:0},nIntensity:{value:.5},sIntensity:{value:.05},sCount:{value:4096},grayscale:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\n\t\t// control parameter\n\t\tuniform float time;\n\n\t\tuniform bool grayscale;\n\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\tuniform float nIntensity;\n\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\tuniform float sIntensity;\n\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\tuniform float sCount;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t// sample the source\n\t\t\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );\n\n\t\t// make some noise\n\t\t\tfloat dx = rand( vUv + time );\n\n\t\t// add noise\n\t\t\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\n\n\t\t// get us a sine and cosine\n\t\t\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\n\n\t\t// add scanlines\n\t\t\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\n\n\t\t// interpolate between source and result by intensity\n\t\t\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\n\n\t\t// convert to grayscale if desired\n\t\t\tif( grayscale ) {\n\n\t\t\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\n\n\t\t\t}\n\n\t\t\tgl_FragColor =  vec4( cResult, cTextureScreen.a );\n\n\t\t}"};class C extends h{constructor(e,t,s,r){super(),void 0===S&&console.error("THREE.FilmPass relies on FilmShader");const n=S;this.uniforms=i.rDY.clone(n.uniforms),this.material=new i.jyz({uniforms:this.uniforms,vertexShader:n.vertexShader,fragmentShader:n.fragmentShader}),void 0!==r&&(this.uniforms.grayscale.value=r),void 0!==e&&(this.uniforms.nIntensity.value=e),void 0!==t&&(this.uniforms.sIntensity.value=t),void 0!==s&&(this.uniforms.sCount.value=s),this.fsQuad=new d(this.material)}render(e,t,s,i){this.uniforms.tDiffuse.value=s.texture,this.uniforms.time.value+=i,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(),this.fsQuad.render(e))}}class b{constructor(e=new Map){this.leaveCallback=()=>{var e;null===(e=this.gui)||void 0===e||e.destroy()},this.render=e=>{let t=this.thenTime-.001*e;this.thenTime=.001*e,this.objects.box.children.forEach((e=>{e.rotation.set(this.thenTime,this.thenTime,this.thenTime)})),this.composer.render(t)},this.animate=e=>{this.render(e),this.animationId.set("postProcessDemo",requestAnimationFrame(this.animate))},this.animationId=e,this.scene=null,this.objects={},this.light=[],this.camera=null,this.renderer=null,this.helper=[],this.composer=null,this.thenTime=0,this.data={isHideHelper:"/"===window.location.pathname},this.gui=this.data.isHideHelper?null:new a.XS}async init(e){this.canvasContainer=null===e||void 0===e?void 0:e.current,(0,n.e)(this.canvasContainer),this.initThree(),this.initCamera(),this.initControl(),await this.initObjects(),this.initLight(),this.initHelper(),await this.initScene(),this.initPass(),requestAnimationFrame(this.animate)}initPass(){const e=new v(this.renderer);e.addPass(new p(this.scene,this.camera));const t=new T(1,25,4,256);e.addPass(t);const s=new C(.35,.025,628,!1);s.renderToScreen=!0,e.addPass(s),this.composer=e}initControl(){this.control=new r.z(this.camera,this.renderer.domElement)}initThree(){this.renderer=new i.CP7,this.renderer.setSize(this.canvasContainer.clientWidth,this.canvasContainer.clientHeight),this.canvasContainer.appendChild(this.renderer.domElement)}async initScene(){this.scene=new i.xsS,this.scene.add(...Object.values(this.objects)),this.scene.add(...this.helper,...this.light)}initHelper(){this.data.isHideHelper||this.helper.forEach((e=>{e.material&&(e.material.depthTest=!1,e.renderOrder=2),void 0!==e.visible&&(e.visible=!1)}))}async initObjects(){{let e=new i.DvJ(.3,.3,.3),t=new i.ZAu;for(let s=0;s<3;s++){let r=new i.xoR({color:16777215*Math.random()}),n=new i.Kj0(e,r);n.position.setX(.45*s-.5),t.add(n)}this.objects.box=t}}initCamera(){this.camera=new i.cPb(45,this.canvasContainer.clientWidth/this.canvasContainer.clientHeight,.1,2),this.camera.position.set(0,0,1),this.camera.lookAt(0,0,0)}initLight(){{let e=new i.Mig(16777215,.6);this.light.push(e)}}}}}]);