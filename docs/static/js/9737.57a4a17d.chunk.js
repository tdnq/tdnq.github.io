"use strict";(self.webpackChunktdnq_github_io=self.webpackChunktdnq_github_io||[]).push([[9737],{9737:function(e,t,r){r.d(t,{qf:function(){return o},$1:function(){return n}});var i=r(3562);function o(e){for(var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),a={},s={},f=e[0].morphTargetsRelative,l=new i.u9r,m=0,h=0;h<e.length;++h){var g=e[h],b=0;if(r!==(null!==g.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(var c in g.attributes){if(!o.has(c))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+c+'" attribute exists among all geometries, or in none of them.'),null;void 0===a[c]&&(a[c]=[]),a[c].push(g.attributes[c]),b++}if(b!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(f!==g.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(var d in g.morphAttributes){if(!n.has(d))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[d]&&(s[d]=[]),s[d].push(g.morphAttributes[d])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(g.userData),t){var v=void 0;if(r)v=g.index.count;else{if(void 0===g.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;v=g.attributes.position.count}l.addGroup(m,v,h),m+=v}}if(r){for(var p=0,y=[],A=0;A<e.length;++A){for(var B=e[A].index,E=0;E<B.count;++E)y.push(B.getX(E)+p);p+=e[A].attributes.position.count}l.setIndex(y)}for(var w in a){var G=u(a[w]);if(!G)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+w+" attribute."),null;l.setAttribute(w,G)}for(var T in s){var x=s[T][0].length;if(0===x)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[T]=[];for(var R=0;R<x;++R){for(var U=[],z=0;z<s[T].length;++z)U.push(s[T][z][R]);var H=u(U);if(!H)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+T+" morphAttribute."),null;l.morphAttributes[T].push(H)}}return l}function u(e){for(var t,r,o,u=0,n=0;n<e.length;++n){var a=e[n];if(a.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=a.array.constructor),t!==a.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=a.itemSize),r!==a.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=a.normalized),o!==a.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;u+=a.array.length}for(var s=new t(u),f=0,l=0;l<e.length;++l)s.set(e[l].array,f),f+=e[l].array.length;return new i.TlE(s,r,o)}function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-4;t=Math.max(t,Number.EPSILON);for(var r={},o=e.getIndex(),u=e.getAttribute("position"),n=o?o.count:u.count,a=0,s=Object.keys(e.attributes),f={},l={},m=[],h=["getX","getY","getZ","getW"],g=0,b=s.length;g<b;g++){var c=s[g];f[c]=[];var d=e.morphAttributes[c];d&&(l[c]=new Array(d.length).fill().map((function(){return[]})))}for(var v=Math.log10(1/t),p=Math.pow(10,v),y=0;y<n;y++){for(var A=o?o.getX(y):y,B="",E=0,w=s.length;E<w;E++)for(var G=s[E],T=e.getAttribute(G),x=T.itemSize,R=0;R<x;R++)B+="".concat(~~(T[h[R]](A)*p),",");if(B in r)m.push(r[B]);else{for(var U=0,z=s.length;U<z;U++)for(var H=s[U],k=e.getAttribute(H),S=e.morphAttributes[H],D=k.itemSize,I=f[H],M=l[H],O=0;O<D;O++){var _=h[O];if(I.push(k[_](A)),S)for(var j=0,q=S.length;j<q;j++)M[j].push(S[j][_](A))}r[B]=a,m.push(a),a++}}for(var X=e.clone(),C=0,N=s.length;C<N;C++){var L=s[C],P=e.getAttribute(L),W=new P.array.constructor(f[L]),Y=new i.TlE(W,P.itemSize,P.normalized);if(X.setAttribute(L,Y),L in l)for(var Z=0;Z<l[L].length;Z++){var $=e.morphAttributes[L][Z],F=new $.array.constructor(l[L][Z]),J=new i.TlE(F,$.itemSize,$.normalized);X.morphAttributes[L][Z]=J}}return X.setIndex(m),X}}}]);